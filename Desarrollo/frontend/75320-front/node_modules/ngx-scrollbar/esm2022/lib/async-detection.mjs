import { Directive, inject, effect, untracked, input, NgZone } from '@angular/core';
import { ContentObserver } from '@angular/cdk/observers';
import { throttleTime } from 'rxjs';
import { NgScrollbarExt } from './ng-scrollbar-ext';
import * as i0 from "@angular/core";
export class AsyncDetection {
    constructor() {
        this.scrollbar = inject(NgScrollbarExt, { self: true });
        this.zone = inject(NgZone);
        this.contentObserver = inject(ContentObserver);
        this.asyncDetection = input();
        this.scrollbar.skipInit = true;
        let sub$;
        effect((onCleanup) => {
            const init = this.scrollbar.viewport.initialized();
            const externalViewport = this.scrollbar.externalViewport();
            const externalContentWrapper = this.scrollbar.externalContentWrapper();
            const externalSpacer = this.scrollbar.externalSpacer();
            const asyncDetection = this.asyncDetection();
            untracked(() => {
                let viewportElement;
                let contentWrapperElement;
                this.zone.runOutsideAngular(() => {
                    // The content observer should not be throttled using the same function we use for ResizeObserver,
                    // It should detect the content change asap to attach the scrollbar
                    sub$ = this.contentObserver.observe(this.scrollbar.nativeElement).pipe(throttleTime(100, null, {
                        leading: true,
                        trailing: true
                    })).subscribe(() => {
                        // Search for external viewport
                        viewportElement = this.scrollbar.nativeElement.querySelector(externalViewport);
                        // Search for external content wrapper
                        contentWrapperElement = this.scrollbar.nativeElement.querySelector(externalContentWrapper);
                        this.zone.run(() => {
                            if (!init && viewportElement && contentWrapperElement) {
                                // If an external spacer selector is provided, search for it
                                let spacerElement;
                                if (externalSpacer) {
                                    spacerElement = this.scrollbar.nativeElement.querySelector(externalSpacer);
                                }
                                this.scrollbar.skipInit = false;
                                this.scrollbar.altViewport.set(viewportElement);
                                this.scrollbar.altContentWrapper.set(contentWrapperElement);
                                this.scrollbar.altSpacer.set(spacerElement);
                            }
                            else if (!viewportElement || !contentWrapperElement) {
                                this.scrollbar.viewport.reset();
                            }
                        });
                        if (asyncDetection !== 'auto') {
                            sub$.unsubscribe();
                        }
                    });
                });
                onCleanup(() => sub$?.unsubscribe());
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: AsyncDetection, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.11", type: AsyncDetection, isStandalone: true, selector: "ng-scrollbar[externalViewport][asyncDetection]", inputs: { asyncDetection: { classPropertyName: "asyncDetection", publicName: "asyncDetection", isSignal: true, isRequired: false, transformFunction: null } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: AsyncDetection, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: 'ng-scrollbar[externalViewport][asyncDetection]'
                }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN5bmMtZGV0ZWN0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zcmMvbGliL2FzeW5jLWRldGVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULE1BQU0sRUFDTixNQUFNLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBR1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pELE9BQU8sRUFBZ0IsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7QUFNcEQsTUFBTSxPQUFPLGNBQWM7SUFTekI7UUFQaUIsY0FBUyxHQUFtQixNQUFNLENBQUMsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDbkUsU0FBSSxHQUFXLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUU5QixvQkFBZSxHQUFvQixNQUFNLENBQUMsZUFBZSxDQUFDLENBQUM7UUFFNUUsbUJBQWMsR0FBNkIsS0FBSyxFQUFFLENBQUM7UUFHakQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQy9CLElBQUksSUFBa0IsQ0FBQztRQUV2QixNQUFNLENBQUMsQ0FBQyxTQUFrQyxFQUFFLEVBQUU7WUFDNUMsTUFBTSxJQUFJLEdBQVksSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDNUQsTUFBTSxnQkFBZ0IsR0FBVyxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDbkUsTUFBTSxzQkFBc0IsR0FBVyxJQUFJLENBQUMsU0FBUyxDQUFDLHNCQUFzQixFQUFFLENBQUM7WUFDL0UsTUFBTSxjQUFjLEdBQVcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUMvRCxNQUFNLGNBQWMsR0FBZ0IsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBRTFELFNBQVMsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2IsSUFBSSxlQUE0QixDQUFDO2dCQUNqQyxJQUFJLHFCQUFrQyxDQUFDO2dCQUV2QyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtvQkFDL0Isa0dBQWtHO29CQUNsRyxtRUFBbUU7b0JBQ25FLElBQUksR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FDcEUsWUFBWSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUU7d0JBQ3RCLE9BQU8sRUFBRSxJQUFJO3dCQUNiLFFBQVEsRUFBRSxJQUFJO3FCQUNmLENBQUMsQ0FDSCxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7d0JBQ2YsK0JBQStCO3dCQUMvQixlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLENBQUM7d0JBRS9FLHNDQUFzQzt3QkFDdEMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLHNCQUFzQixDQUFDLENBQUM7d0JBRTNGLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTs0QkFDakIsSUFBSSxDQUFDLElBQUksSUFBSSxlQUFlLElBQUkscUJBQXFCLEVBQUUsQ0FBQztnQ0FDdEQsNERBQTREO2dDQUM1RCxJQUFJLGFBQTBCLENBQUM7Z0NBQy9CLElBQUksY0FBYyxFQUFFLENBQUM7b0NBQ25CLGFBQWEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLENBQUM7Z0NBQzdFLENBQUM7Z0NBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO2dDQUNoQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7Z0NBQ2hELElBQUksQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUM7Z0NBQzVELElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQzs0QkFDOUMsQ0FBQztpQ0FBTSxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztnQ0FDdEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUM7NEJBQ2xDLENBQUM7d0JBQ0gsQ0FBQyxDQUFDLENBQUM7d0JBRUgsSUFBSSxjQUFjLEtBQUssTUFBTSxFQUFFLENBQUM7NEJBQzlCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzt3QkFDckIsQ0FBQztvQkFDSCxDQUFDLENBQUMsQ0FBQztnQkFDTCxDQUFDLENBQUMsQ0FBQztnQkFFSCxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUM7WUFDdkMsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7K0dBakVVLGNBQWM7bUdBQWQsY0FBYzs7NEZBQWQsY0FBYztrQkFKMUIsU0FBUzttQkFBQztvQkFDVCxVQUFVLEVBQUUsSUFBSTtvQkFDaEIsUUFBUSxFQUFFLGdEQUFnRDtpQkFDM0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIERpcmVjdGl2ZSxcclxuICBpbmplY3QsXHJcbiAgZWZmZWN0LFxyXG4gIHVudHJhY2tlZCxcclxuICBpbnB1dCxcclxuICBOZ1pvbmUsXHJcbiAgSW5wdXRTaWduYWwsXHJcbiAgRWZmZWN0Q2xlYW51cFJlZ2lzdGVyRm5cclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udGVudE9ic2VydmVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL29ic2VydmVycyc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgdGhyb3R0bGVUaW1lIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE5nU2Nyb2xsYmFyRXh0IH0gZnJvbSAnLi9uZy1zY3JvbGxiYXItZXh0JztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHN0YW5kYWxvbmU6IHRydWUsXHJcbiAgc2VsZWN0b3I6ICduZy1zY3JvbGxiYXJbZXh0ZXJuYWxWaWV3cG9ydF1bYXN5bmNEZXRlY3Rpb25dJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgQXN5bmNEZXRlY3Rpb24ge1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IHNjcm9sbGJhcjogTmdTY3JvbGxiYXJFeHQgPSBpbmplY3QoTmdTY3JvbGxiYXJFeHQsIHsgc2VsZjogdHJ1ZSB9KTtcclxuICBwcml2YXRlIHJlYWRvbmx5IHpvbmU6IE5nWm9uZSA9IGluamVjdChOZ1pvbmUpO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRlbnRPYnNlcnZlcjogQ29udGVudE9ic2VydmVyID0gaW5qZWN0KENvbnRlbnRPYnNlcnZlcik7XHJcblxyXG4gIGFzeW5jRGV0ZWN0aW9uOiBJbnB1dFNpZ25hbDwnYXV0bycgfCAnJz4gPSBpbnB1dCgpO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuc2Nyb2xsYmFyLnNraXBJbml0ID0gdHJ1ZTtcclxuICAgIGxldCBzdWIkOiBTdWJzY3JpcHRpb247XHJcblxyXG4gICAgZWZmZWN0KChvbkNsZWFudXA6IEVmZmVjdENsZWFudXBSZWdpc3RlckZuKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluaXQ6IGJvb2xlYW4gPSB0aGlzLnNjcm9sbGJhci52aWV3cG9ydC5pbml0aWFsaXplZCgpO1xyXG4gICAgICBjb25zdCBleHRlcm5hbFZpZXdwb3J0OiBzdHJpbmcgPSB0aGlzLnNjcm9sbGJhci5leHRlcm5hbFZpZXdwb3J0KCk7XHJcbiAgICAgIGNvbnN0IGV4dGVybmFsQ29udGVudFdyYXBwZXI6IHN0cmluZyA9IHRoaXMuc2Nyb2xsYmFyLmV4dGVybmFsQ29udGVudFdyYXBwZXIoKTtcclxuICAgICAgY29uc3QgZXh0ZXJuYWxTcGFjZXI6IHN0cmluZyA9IHRoaXMuc2Nyb2xsYmFyLmV4dGVybmFsU3BhY2VyKCk7XHJcbiAgICAgIGNvbnN0IGFzeW5jRGV0ZWN0aW9uOiAnYXV0bycgfCAnJyA9IHRoaXMuYXN5bmNEZXRlY3Rpb24oKTtcclxuXHJcbiAgICAgIHVudHJhY2tlZCgoKSA9PiB7XHJcbiAgICAgICAgbGV0IHZpZXdwb3J0RWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGNvbnRlbnRXcmFwcGVyRWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgICAvLyBUaGUgY29udGVudCBvYnNlcnZlciBzaG91bGQgbm90IGJlIHRocm90dGxlZCB1c2luZyB0aGUgc2FtZSBmdW5jdGlvbiB3ZSB1c2UgZm9yIFJlc2l6ZU9ic2VydmVyLFxyXG4gICAgICAgICAgLy8gSXQgc2hvdWxkIGRldGVjdCB0aGUgY29udGVudCBjaGFuZ2UgYXNhcCB0byBhdHRhY2ggdGhlIHNjcm9sbGJhclxyXG4gICAgICAgICAgc3ViJCA9IHRoaXMuY29udGVudE9ic2VydmVyLm9ic2VydmUodGhpcy5zY3JvbGxiYXIubmF0aXZlRWxlbWVudCkucGlwZShcclxuICAgICAgICAgICAgdGhyb3R0bGVUaW1lKDEwMCwgbnVsbCwge1xyXG4gICAgICAgICAgICAgIGxlYWRpbmc6IHRydWUsXHJcbiAgICAgICAgICAgICAgdHJhaWxpbmc6IHRydWVcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBleHRlcm5hbCB2aWV3cG9ydFxyXG4gICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnQgPSB0aGlzLnNjcm9sbGJhci5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoZXh0ZXJuYWxWaWV3cG9ydCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZWFyY2ggZm9yIGV4dGVybmFsIGNvbnRlbnQgd3JhcHBlclxyXG4gICAgICAgICAgICBjb250ZW50V3JhcHBlckVsZW1lbnQgPSB0aGlzLnNjcm9sbGJhci5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoZXh0ZXJuYWxDb250ZW50V3JhcHBlcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoIWluaXQgJiYgdmlld3BvcnRFbGVtZW50ICYmIGNvbnRlbnRXcmFwcGVyRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gZXh0ZXJuYWwgc3BhY2VyIHNlbGVjdG9yIGlzIHByb3ZpZGVkLCBzZWFyY2ggZm9yIGl0XHJcbiAgICAgICAgICAgICAgICBsZXQgc3BhY2VyRWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWxTcGFjZXIpIHtcclxuICAgICAgICAgICAgICAgICAgc3BhY2VyRWxlbWVudCA9IHRoaXMuc2Nyb2xsYmFyLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihleHRlcm5hbFNwYWNlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxiYXIuc2tpcEluaXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsYmFyLmFsdFZpZXdwb3J0LnNldCh2aWV3cG9ydEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxiYXIuYWx0Q29udGVudFdyYXBwZXIuc2V0KGNvbnRlbnRXcmFwcGVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGJhci5hbHRTcGFjZXIuc2V0KHNwYWNlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXZpZXdwb3J0RWxlbWVudCB8fCAhY29udGVudFdyYXBwZXJFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGJhci52aWV3cG9ydC5yZXNldCgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXN5bmNEZXRlY3Rpb24gIT09ICdhdXRvJykge1xyXG4gICAgICAgICAgICAgIHN1YiQudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9uQ2xlYW51cCgoKSA9PiBzdWIkPy51bnN1YnNjcmliZSgpKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIl19