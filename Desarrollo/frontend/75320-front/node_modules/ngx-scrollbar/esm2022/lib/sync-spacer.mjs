import { Directive, inject, signal, effect, untracked, NgZone } from '@angular/core';
import { SharedResizeObserver } from '@angular/cdk/observers/private';
import { map } from 'rxjs';
import { NgScrollbarExt } from './ng-scrollbar-ext';
import { filterResizeEntries } from './ng-scrollbar.model';
import { getThrottledStream } from './utils/common';
import * as i0 from "@angular/core";
export class SyncSpacer {
    constructor() {
        this.sharedResizeObserver = inject(SharedResizeObserver);
        this.scrollbar = inject(NgScrollbarExt, { self: true });
        this.zone = inject(NgZone);
        /**
         * A signal used to sync spacer dimension when content dimension changes
         */
        this.spacerDimension = signal({});
        let sub$;
        effect((onCleanup) => {
            const spacerElement = this.scrollbar.spacerElement();
            const contentWrapperElement = this.scrollbar.contentWrapperElement();
            const throttleDuration = this.scrollbar.sensorThrottleTime();
            const disableSensor = this.scrollbar.disableSensor();
            untracked(() => {
                if (!disableSensor && contentWrapperElement && spacerElement) {
                    // Sync spacer dimension with content wrapper dimensions to allow both scrollbars to be displayed
                    this.zone.runOutsideAngular(() => {
                        sub$ = getThrottledStream(this.sharedResizeObserver.observe(contentWrapperElement), throttleDuration).pipe(map((entries) => filterResizeEntries(entries, contentWrapperElement))).subscribe(() => {
                            this.zone.run(() => {
                                // Use animation frame to avoid "ResizeObserver loop completed with undelivered notifications." error
                                requestAnimationFrame(() => {
                                    this.spacerDimension.set({
                                        width: contentWrapperElement.offsetWidth,
                                        height: contentWrapperElement.offsetHeight
                                    });
                                });
                            });
                        });
                    });
                }
                onCleanup(() => sub$?.unsubscribe());
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: SyncSpacer, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.11", type: SyncSpacer, isStandalone: true, selector: "ng-scrollbar[externalViewport][syncSpacer]", host: { properties: { "style.--spacer-width": "spacerDimension().width", "style.--spacer-height": "spacerDimension().height" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: SyncSpacer, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: 'ng-scrollbar[externalViewport][syncSpacer]',
                    host: {
                        '[style.--spacer-width]': 'spacerDimension().width',
                        '[style.--spacer-height]': 'spacerDimension().height'
                    }
                }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3luYy1zcGFjZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc2Nyb2xsYmFyL3NyYy9saWIvc3luYy1zcGFjZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxNQUFNLEVBQ04sTUFBTSxFQUNOLE1BQU0sRUFDTixTQUFTLEVBQ1QsTUFBTSxFQUdQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3RFLE9BQU8sRUFBZ0IsR0FBRyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMzRCxPQUFPLEVBQW9CLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7O0FBVXRFLE1BQU0sT0FBTyxVQUFVO0lBYXJCO1FBWGlCLHlCQUFvQixHQUF5QixNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUUxRSxjQUFTLEdBQW1CLE1BQU0sQ0FBQyxjQUFjLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUVuRSxTQUFJLEdBQVcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRS9DOztXQUVHO1FBQ0gsb0JBQWUsR0FBcUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRzdELElBQUksSUFBa0IsQ0FBQztRQUV2QixNQUFNLENBQUMsQ0FBQyxTQUFrQyxFQUFFLEVBQUU7WUFDNUMsTUFBTSxhQUFhLEdBQWdCLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDbEUsTUFBTSxxQkFBcUIsR0FBZ0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1lBQ2xGLE1BQU0sZ0JBQWdCLEdBQVcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQ3JFLE1BQU0sYUFBYSxHQUFZLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLENBQUM7WUFFOUQsU0FBUyxDQUFDLEdBQUcsRUFBRTtnQkFDYixJQUFJLENBQUMsYUFBYSxJQUFJLHFCQUFxQixJQUFJLGFBQWEsRUFBRSxDQUFDO29CQUM3RCxpR0FBaUc7b0JBQ2pHLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFO3dCQUMvQixJQUFJLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUN4RyxHQUFHLENBQUMsQ0FBQyxPQUE4QixFQUFFLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUscUJBQXFCLENBQUMsQ0FBQyxDQUM3RixDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7NEJBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFO2dDQUNqQixxR0FBcUc7Z0NBQ3JHLHFCQUFxQixDQUFDLEdBQUcsRUFBRTtvQ0FDekIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUM7d0NBQ3ZCLEtBQUssRUFBRSxxQkFBcUIsQ0FBQyxXQUFXO3dDQUN4QyxNQUFNLEVBQUUscUJBQXFCLENBQUMsWUFBWTtxQ0FDM0MsQ0FBQyxDQUFDO2dDQUNMLENBQUMsQ0FBQyxDQUFDOzRCQUNMLENBQUMsQ0FBQyxDQUFDO3dCQUNMLENBQUMsQ0FBQyxDQUFDO29CQUNMLENBQUMsQ0FBQyxDQUFDO2dCQUNMLENBQUM7Z0JBQ0QsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZDLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDOytHQTVDVSxVQUFVO21HQUFWLFVBQVU7OzRGQUFWLFVBQVU7a0JBUnRCLFNBQVM7bUJBQUM7b0JBQ1QsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLFFBQVEsRUFBRSw0Q0FBNEM7b0JBQ3RELElBQUksRUFBRTt3QkFDSix3QkFBd0IsRUFBRSx5QkFBeUI7d0JBQ25ELHlCQUF5QixFQUFFLDBCQUEwQjtxQkFDdEQ7aUJBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIERpcmVjdGl2ZSxcclxuICBpbmplY3QsXHJcbiAgc2lnbmFsLFxyXG4gIGVmZmVjdCxcclxuICB1bnRyYWNrZWQsXHJcbiAgTmdab25lLFxyXG4gIFdyaXRhYmxlU2lnbmFsLFxyXG4gIEVmZmVjdENsZWFudXBSZWdpc3RlckZuXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFNoYXJlZFJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL29ic2VydmVycy9wcml2YXRlJztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBtYXAgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgTmdTY3JvbGxiYXJFeHQgfSBmcm9tICcuL25nLXNjcm9sbGJhci1leHQnO1xyXG5pbXBvcnQgeyBmaWx0ZXJSZXNpemVFbnRyaWVzIH0gZnJvbSAnLi9uZy1zY3JvbGxiYXIubW9kZWwnO1xyXG5pbXBvcnQgeyBFbGVtZW50RGltZW5zaW9uLCBnZXRUaHJvdHRsZWRTdHJlYW0gfSBmcm9tICcuL3V0aWxzL2NvbW1vbic7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzdGFuZGFsb25lOiB0cnVlLFxyXG4gIHNlbGVjdG9yOiAnbmctc2Nyb2xsYmFyW2V4dGVybmFsVmlld3BvcnRdW3N5bmNTcGFjZXJdJyxcclxuICBob3N0OiB7XHJcbiAgICAnW3N0eWxlLi0tc3BhY2VyLXdpZHRoXSc6ICdzcGFjZXJEaW1lbnNpb24oKS53aWR0aCcsXHJcbiAgICAnW3N0eWxlLi0tc3BhY2VyLWhlaWdodF0nOiAnc3BhY2VyRGltZW5zaW9uKCkuaGVpZ2h0J1xyXG4gIH1cclxufSlcclxuZXhwb3J0IGNsYXNzIFN5bmNTcGFjZXIge1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IHNoYXJlZFJlc2l6ZU9ic2VydmVyOiBTaGFyZWRSZXNpemVPYnNlcnZlciA9IGluamVjdChTaGFyZWRSZXNpemVPYnNlcnZlcik7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhckV4dCA9IGluamVjdChOZ1Njcm9sbGJhckV4dCwgeyBzZWxmOiB0cnVlIH0pO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IHpvbmU6IE5nWm9uZSA9IGluamVjdChOZ1pvbmUpO1xyXG5cclxuICAvKipcclxuICAgKiBBIHNpZ25hbCB1c2VkIHRvIHN5bmMgc3BhY2VyIGRpbWVuc2lvbiB3aGVuIGNvbnRlbnQgZGltZW5zaW9uIGNoYW5nZXNcclxuICAgKi9cclxuICBzcGFjZXJEaW1lbnNpb246IFdyaXRhYmxlU2lnbmFsPEVsZW1lbnREaW1lbnNpb24+ID0gc2lnbmFsKHt9KTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBsZXQgc3ViJDogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAgIGVmZmVjdCgob25DbGVhbnVwOiBFZmZlY3RDbGVhbnVwUmVnaXN0ZXJGbikgPT4ge1xyXG4gICAgICBjb25zdCBzcGFjZXJFbGVtZW50OiBIVE1MRWxlbWVudCA9IHRoaXMuc2Nyb2xsYmFyLnNwYWNlckVsZW1lbnQoKTtcclxuICAgICAgY29uc3QgY29udGVudFdyYXBwZXJFbGVtZW50OiBIVE1MRWxlbWVudCA9IHRoaXMuc2Nyb2xsYmFyLmNvbnRlbnRXcmFwcGVyRWxlbWVudCgpO1xyXG4gICAgICBjb25zdCB0aHJvdHRsZUR1cmF0aW9uOiBudW1iZXIgPSB0aGlzLnNjcm9sbGJhci5zZW5zb3JUaHJvdHRsZVRpbWUoKTtcclxuICAgICAgY29uc3QgZGlzYWJsZVNlbnNvcjogYm9vbGVhbiA9IHRoaXMuc2Nyb2xsYmFyLmRpc2FibGVTZW5zb3IoKTtcclxuXHJcbiAgICAgIHVudHJhY2tlZCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFkaXNhYmxlU2Vuc29yICYmIGNvbnRlbnRXcmFwcGVyRWxlbWVudCAmJiBzcGFjZXJFbGVtZW50KSB7XHJcbiAgICAgICAgICAvLyBTeW5jIHNwYWNlciBkaW1lbnNpb24gd2l0aCBjb250ZW50IHdyYXBwZXIgZGltZW5zaW9ucyB0byBhbGxvdyBib3RoIHNjcm9sbGJhcnMgdG8gYmUgZGlzcGxheWVkXHJcbiAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICBzdWIkID0gZ2V0VGhyb3R0bGVkU3RyZWFtKHRoaXMuc2hhcmVkUmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb250ZW50V3JhcHBlckVsZW1lbnQpLCB0aHJvdHRsZUR1cmF0aW9uKS5waXBlKFxyXG4gICAgICAgICAgICAgIG1hcCgoZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSA9PiBmaWx0ZXJSZXNpemVFbnRyaWVzKGVudHJpZXMsIGNvbnRlbnRXcmFwcGVyRWxlbWVudCkpLFxyXG4gICAgICAgICAgICApLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgYW5pbWF0aW9uIGZyYW1lIHRvIGF2b2lkIFwiUmVzaXplT2JzZXJ2ZXIgbG9vcCBjb21wbGV0ZWQgd2l0aCB1bmRlbGl2ZXJlZCBub3RpZmljYXRpb25zLlwiIGVycm9yXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLnNwYWNlckRpbWVuc2lvbi5zZXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb250ZW50V3JhcHBlckVsZW1lbnQub2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjb250ZW50V3JhcHBlckVsZW1lbnQub2Zmc2V0SGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uQ2xlYW51cCgoKSA9PiBzdWIkPy51bnN1YnNjcmliZSgpKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIl19