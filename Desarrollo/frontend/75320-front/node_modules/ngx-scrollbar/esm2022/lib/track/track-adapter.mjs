import { Directive, effect, inject, PLATFORM_ID, untracked } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { delay, fromEvent, map, merge, startWith, switchMap, takeUntil, takeWhile, tap, EMPTY } from 'rxjs';
import { enableSelection, preventSelection, stopPropagation } from '../utils/common';
import { PointerEventsAdapter } from '../utils/pointer-events-adapter';
import * as i0 from "@angular/core";
export class TrackAdapter extends PointerEventsAdapter {
    // Returns viewport client size
    get viewportSize() {
        return this.cmp.viewport[this.control.sizeProperty];
    }
    // Get track client rect
    get clientRect() {
        return this.nativeElement.getBoundingClientRect();
    }
    // Scrollbar track offset
    get offset() {
        return this.clientRect[this.control.rectOffsetProperty];
    }
    // Scrollbar track length
    get size() {
        // Noticed that clientHeight is evaluated before getClientRect.height,
        // causing a wrong track size when integrated in dropdown integration
        return this.nativeElement[this.control.sizeProperty];
    }
    // Observable for track dragging events
    get pointerEvents() {
        // Observable streams for pointer events
        const pointerDown$ = fromEvent(this.nativeElement, 'pointerdown').pipe(stopPropagation(), preventSelection(this.document));
        const pointerUp$ = fromEvent(this.document, 'pointerup', { passive: true }).pipe(enableSelection(this.document));
        const pointerEnter$ = fromEvent(this.nativeElement, 'pointerover', { passive: true }).pipe(
        // When mouse is out and enters again, must set the current position first
        tap((e) => this.currMousePosition = e[this.control.offsetProperty]), map(() => true));
        const pointerLeave$ = fromEvent(this.nativeElement, 'pointerout', { passive: true }).pipe(map(() => false));
        const pointerOver$ = merge(pointerEnter$, pointerLeave$).pipe(startWith(true));
        // Keep track of current mouse location while dragging
        const pointerMove$ = fromEvent(this.nativeElement, 'pointermove', { passive: true }).pipe(tap((e) => this.currMousePosition = e[this.control.offsetProperty]));
        return pointerDown$.pipe(switchMap((startEvent) => {
            // Track pointer location while dragging
            pointerMove$.pipe(takeUntil(pointerUp$)).subscribe();
            return this.onTrackFirstClick(startEvent).pipe(delay(200), switchMap(() => {
                // Otherwise, activate pointermove and pointerout events and switch to ongoing scroll calls
                return pointerOver$.pipe(switchMap((over) => {
                    const currDirection = this.getScrollDirection(this.currMousePosition);
                    const sameDirection = this.scrollDirection === currDirection;
                    // If mouse is out the track pause the scroll calls, otherwise keep going
                    return (over && sameDirection) ? this.onTrackOngoingMousedown() : EMPTY;
                }));
            }), takeUntil(pointerUp$));
        }));
    }
    constructor() {
        effect(() => {
            this.cmp.viewportDimension();
            this.cmp.contentDimension();
            // Avoid SSR error because we're using `requestAnimationFrame`
            if (!this.isBrowser)
                return;
            untracked(() => {
                // Use animation frame to give the track element time to render (avoid size 0)
                requestAnimationFrame(() => this.control.trackSize.set(this.size));
            });
        });
        super();
        this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
    }
    /**
     *  Callback when mouse is first clicked on the track
     */
    onTrackFirstClick(e) {
        // Initialize variables and determine scroll direction
        this.currMousePosition = e[this.control.offsetProperty];
        this.scrollDirection = this.getScrollDirection(this.currMousePosition);
        this.scrollMax = this.control.viewportScrollMax;
        return this.scrollTo(this.nextStep());
    }
    nextStep() {
        // Check which direction should the scroll go (forward or backward)
        if (this.scrollDirection === 'forward') {
            // Scroll forward
            const scrollForwardIncrement = this.getScrollForwardStep();
            // Check if the incremental position is bigger than the scroll max
            if (scrollForwardIncrement >= this.scrollMax) {
                return this.scrollMax;
            }
            return scrollForwardIncrement;
        }
        // Scroll backward
        const scrollBackwardIncrement = this.getScrollBackwardStep();
        if (scrollBackwardIncrement <= 0) {
            return 0;
        }
        return scrollBackwardIncrement;
    }
    /**
     * Callback when mouse is still down on the track
     * Incrementally scrolls towards target position until reached
     */
    onTrackOngoingMousedown() {
        const position = this.nextStep();
        return this.scrollTo(position).pipe(takeWhile(() => !this.isReached(position)), switchMap(() => this.onTrackOngoingMousedown()));
    }
    /**
     * Returns a flag that determines whether the scroll from the given position is the final step or not
     */
    isReached(position) {
        if (this.scrollDirection === 'forward') {
            return position >= this.scrollMax;
        }
        return position <= 0;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: TrackAdapter, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.11", type: TrackAdapter, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: TrackAdapter, decorators: [{
            type: Directive
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2stYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1zY3JvbGxiYXIvc3JjL2xpYi90cmFjay90cmFjay1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3BELE9BQU8sRUFFTCxLQUFLLEVBQ0wsU0FBUyxFQUNULEdBQUcsRUFDSCxLQUFLLEVBQ0wsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULEdBQUcsRUFDSCxLQUFLLEVBQ04sTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3JGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGlDQUFpQyxDQUFDOztBQUd2RSxNQUFNLE9BQWdCLFlBQWEsU0FBUSxvQkFBb0I7SUFnQjdELCtCQUErQjtJQUMvQixJQUFjLFlBQVk7UUFDeEIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRCx3QkFBd0I7SUFDeEIsSUFBYyxVQUFVO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ3BELENBQUM7SUFXRCx5QkFBeUI7SUFDekIsSUFBSSxNQUFNO1FBQ1IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQseUJBQXlCO0lBQ3pCLElBQUksSUFBSTtR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bmplY3QsIFBMQVRGT1JNX0lELCB1bnRyYWNrZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQge1xyXG4gIE9ic2VydmFibGUsXHJcbiAgZGVsYXksXHJcbiAgZnJvbUV2ZW50LFxyXG4gIG1hcCxcclxuICBtZXJnZSxcclxuICBzdGFydFdpdGgsXHJcbiAgc3dpdGNoTWFwLFxyXG4gIHRha2VVbnRpbCxcclxuICB0YWtlV2hpbGUsXHJcbiAgdGFwLFxyXG4gIEVNUFRZXHJcbn0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGVuYWJsZVNlbGVjdGlvbiwgcHJldmVudFNlbGVjdGlvbiwgc3RvcFByb3BhZ2F0aW9uIH0gZnJvbSAnLi4vdXRpbHMvY29tbW9uJztcclxuaW1wb3J0IHsgUG9pbnRlckV2ZW50c0FkYXB0ZXIgfSBmcm9tICcuLi91dGlscy9wb2ludGVyLWV2ZW50cy1hZGFwdGVyJztcclxuXHJcbkBEaXJlY3RpdmUoKVxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJhY2tBZGFwdGVyIGV4dGVuZHMgUG9pbnRlckV2ZW50c0FkYXB0ZXIge1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGlzQnJvd3NlcjogYm9vbGVhbiA9IGlzUGxhdGZvcm1Ccm93c2VyKGluamVjdChQTEFURk9STV9JRCkpO1xyXG5cclxuICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgbW91c2UgZHVyaW5nIHRyYWNrIGRyYWdnaW5nXHJcbiAgcHJpdmF0ZSBjdXJyTW91c2VQb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuICAvLyBUaGUgZGlyZWN0aW9uIG9mIHNjcm9sbCB3aGVuIHRoZSB0cmFjayBhcmVhIGlzIGNsaWNrZWRcclxuICBwcm90ZWN0ZWQgc2Nyb2xsRGlyZWN0aW9uOiAnZm9yd2FyZCcgfCAnYmFja3dhcmQnO1xyXG5cclxuICAvLyBUaGUgbWF4aW11bSBzY3JvbGwgcG9zaXRpb24gdW50aWwgdGhlIGVuZCBpcyByZWFjaGVkXHJcbiAgcHJvdGVjdGVkIHNjcm9sbE1heDogbnVtYmVyO1xyXG5cclxuICAvLyBSZXR1cm5zIHZpZXdwb3J0IHNjcm9sbCBzaXplXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCBjb250ZW50U2l6ZSgpOiBudW1iZXI7XHJcblxyXG4gIC8vIFJldHVybnMgdmlld3BvcnQgY2xpZW50IHNpemVcclxuICBwcm90ZWN0ZWQgZ2V0IHZpZXdwb3J0U2l6ZSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY21wLnZpZXdwb3J0W3RoaXMuY29udHJvbC5zaXplUHJvcGVydHldO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRyYWNrIGNsaWVudCByZWN0XHJcbiAgcHJvdGVjdGVkIGdldCBjbGllbnRSZWN0KCk6IERPTVJlY3Qge1xyXG4gICAgcmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICB9XHJcblxyXG4gIC8vIFJldHVybnMgdGhlIHNjcm9sbCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdHJhY2tcclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0Q3VyclBvc2l0aW9uKCk6IG51bWJlcjtcclxuXHJcbiAgLy8gUmV0dXJucyB0aGUgZHJhZ2dpbmcgZGlyZWN0aW9uIGZvcndhcmQgb3IgYmFja3dhcmRcclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0U2Nyb2xsRGlyZWN0aW9uKHBvc2l0aW9uOiBudW1iZXIpOiAnZm9yd2FyZCcgfCAnYmFja3dhcmQnO1xyXG5cclxuICAvLyBGdW5jdGlvbiB0aGF0IHNjcm9sbHMgdG8gdGhlIGdpdmVuIHBvc2l0aW9uXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNjcm9sbFRvKHBvc2l0aW9uOiBudW1iZXIpOiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG5cclxuICAvLyBTY3JvbGxiYXIgdHJhY2sgb2Zmc2V0XHJcbiAgZ2V0IG9mZnNldCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xpZW50UmVjdFt0aGlzLmNvbnRyb2wucmVjdE9mZnNldFByb3BlcnR5XTtcclxuICB9XHJcblxyXG4gIC8vIFNjcm9sbGJhciB0cmFjayBsZW5ndGhcclxuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG4gICAgLy8gTm90aWNlZCB0aGF0IGNsaWVudEhlaWdodCBpcyBldmFsdWF0ZWQgYmVmb3JlIGdldENsaWVudFJlY3QuaGVpZ2h0LFxyXG4gICAgLy8gY2F1c2luZyBhIHdyb25nIHRyYWNrIHNpemUgd2hlbiBpbnRlZ3JhdGVkIGluIGRyb3Bkb3duIGludGVncmF0aW9uXHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50W3RoaXMuY29udHJvbC5zaXplUHJvcGVydHldO1xyXG4gIH1cclxuXHJcbiAgLy8gT2JzZXJ2YWJsZSBmb3IgdHJhY2sgZHJhZ2dpbmcgZXZlbnRzXHJcbiAgZ2V0IHBvaW50ZXJFdmVudHMoKTogT2JzZXJ2YWJsZTxQb2ludGVyRXZlbnQ+IHtcclxuICAgIC8vIE9ic2VydmFibGUgc3RyZWFtcyBmb3IgcG9pbnRlciBldmVudHNcclxuICAgIGNvbnN0IHBvaW50ZXJEb3duJDogT2JzZXJ2YWJsZTxQb2ludGVyRXZlbnQ+ID0gZnJvbUV2ZW50PFBvaW50ZXJFdmVudD4odGhpcy5uYXRpdmVFbGVtZW50LCAncG9pbnRlcmRvd24nKS5waXBlKFxyXG4gICAgICBzdG9wUHJvcGFnYXRpb24oKSxcclxuICAgICAgcHJldmVudFNlbGVjdGlvbih0aGlzLmRvY3VtZW50KVxyXG4gICAgKTtcclxuICAgIGNvbnN0IHBvaW50ZXJVcCQ6IE9ic2VydmFibGU8UG9pbnRlckV2ZW50PiA9IGZyb21FdmVudDxQb2ludGVyRXZlbnQ+KHRoaXMuZG9jdW1lbnQsICdwb2ludGVydXAnLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShcclxuICAgICAgZW5hYmxlU2VsZWN0aW9uKHRoaXMuZG9jdW1lbnQpXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHBvaW50ZXJFbnRlciQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSBmcm9tRXZlbnQ8UG9pbnRlckV2ZW50Pih0aGlzLm5hdGl2ZUVsZW1lbnQsICdwb2ludGVyb3ZlcicsIHsgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKFxyXG4gICAgICAvLyBXaGVuIG1vdXNlIGlzIG91dCBhbmQgZW50ZXJzIGFnYWluLCBtdXN0IHNldCB0aGUgY3VycmVudCBwb3NpdGlvbiBmaXJzdFxyXG4gICAgICB0YXAoKGU6IFBvaW50ZXJFdmVudCkgPT4gdGhpcy5jdXJyTW91c2VQb3NpdGlvbiA9IGVbdGhpcy5jb250cm9sLm9mZnNldFByb3BlcnR5XSksXHJcbiAgICAgIG1hcCgoKSA9PiB0cnVlKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IHBvaW50ZXJMZWF2ZSQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSBmcm9tRXZlbnQ8UG9pbnRlckV2ZW50Pih0aGlzLm5hdGl2ZUVsZW1lbnQsICdwb2ludGVyb3V0JywgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUoXHJcbiAgICAgIG1hcCgoKSA9PiBmYWxzZSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgcG9pbnRlck92ZXIkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gbWVyZ2UocG9pbnRlckVudGVyJCwgcG9pbnRlckxlYXZlJCkucGlwZShzdGFydFdpdGgodHJ1ZSkpO1xyXG5cclxuICAgIC8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBtb3VzZSBsb2NhdGlvbiB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgY29uc3QgcG9pbnRlck1vdmUkOiBPYnNlcnZhYmxlPFBvaW50ZXJFdmVudD4gPSBmcm9tRXZlbnQ8UG9pbnRlckV2ZW50Pih0aGlzLm5hdGl2ZUVsZW1lbnQsICdwb2ludGVybW92ZScsIHsgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKFxyXG4gICAgICB0YXAoKGU6IFBvaW50ZXJFdmVudCkgPT4gdGhpcy5jdXJyTW91c2VQb3NpdGlvbiA9IGVbdGhpcy5jb250cm9sLm9mZnNldFByb3BlcnR5XSlcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHBvaW50ZXJEb3duJC5waXBlKFxyXG4gICAgICBzd2l0Y2hNYXAoKHN0YXJ0RXZlbnQ6IFBvaW50ZXJFdmVudCkgPT4ge1xyXG4gICAgICAgIC8vIFRyYWNrIHBvaW50ZXIgbG9jYXRpb24gd2hpbGUgZHJhZ2dpbmdcclxuICAgICAgICBwb2ludGVyTW92ZSQucGlwZSh0YWtlVW50aWwocG9pbnRlclVwJCkpLnN1YnNjcmliZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5vblRyYWNrRmlyc3RDbGljayhzdGFydEV2ZW50KS5waXBlKFxyXG4gICAgICAgICAgZGVsYXkoMjAwKSxcclxuICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYWN0aXZhdGUgcG9pbnRlcm1vdmUgYW5kIHBvaW50ZXJvdXQgZXZlbnRzIGFuZCBzd2l0Y2ggdG8gb25nb2luZyBzY3JvbGwgY2FsbHNcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXJPdmVyJC5waXBlKFxyXG4gICAgICAgICAgICAgIHN3aXRjaE1hcCgob3ZlcjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckRpcmVjdGlvbjogJ2ZvcndhcmQnIHwgJ2JhY2t3YXJkJyA9IHRoaXMuZ2V0U2Nyb2xsRGlyZWN0aW9uKHRoaXMuY3Vyck1vdXNlUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtZURpcmVjdGlvbjogYm9vbGVhbiA9IHRoaXMuc2Nyb2xsRGlyZWN0aW9uID09PSBjdXJyRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgbW91c2UgaXMgb3V0IHRoZSB0cmFjayBwYXVzZSB0aGUgc2Nyb2xsIGNhbGxzLCBvdGhlcndpc2Uga2VlcCBnb2luZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChvdmVyICYmIHNhbWVEaXJlY3Rpb24pID8gdGhpcy5vblRyYWNrT25nb2luZ01vdXNlZG93bigpIDogRU1QVFk7XHJcbiAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICkgYXMgT2JzZXJ2YWJsZTxQb2ludGVyRXZlbnQ+O1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICB0YWtlVW50aWwocG9pbnRlclVwJCksXHJcbiAgICAgICAgKTtcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIHRoaXMuY21wLnZpZXdwb3J0RGltZW5zaW9uKCk7XHJcbiAgICAgIHRoaXMuY21wLmNvbnRlbnREaW1lbnNpb24oKTtcclxuXHJcbiAgICAgIC8vIEF2b2lkIFNTUiBlcnJvciBiZWNhdXNlIHdlJ3JlIHVzaW5nIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXHJcbiAgICAgIGlmICghdGhpcy5pc0Jyb3dzZXIpIHJldHVybjtcclxuXHJcbiAgICAgIHVudHJhY2tlZCgoKSA9PiB7XHJcbiAgICAgICAgLy8gVXNlIGFuaW1hdGlvbiBmcmFtZSB0byBnaXZlIHRoZSB0cmFjayBlbGVtZW50IHRpbWUgdG8gcmVuZGVyIChhdm9pZCBzaXplIDApXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuY29udHJvbC50cmFja1NpemUuc2V0KHRoaXMuc2l6ZSkpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgc3VwZXIoKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBnZXRTY3JvbGxGb3J3YXJkU3RlcCgpOiBudW1iZXI7XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBnZXRTY3JvbGxCYWNrd2FyZFN0ZXAoKTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiAgQ2FsbGJhY2sgd2hlbiBtb3VzZSBpcyBmaXJzdCBjbGlja2VkIG9uIHRoZSB0cmFja1xyXG4gICAqL1xyXG4gIG9uVHJhY2tGaXJzdENsaWNrKGU6IFBvaW50ZXJFdmVudCk6IE9ic2VydmFibGU8dm9pZD4ge1xyXG4gICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMgYW5kIGRldGVybWluZSBzY3JvbGwgZGlyZWN0aW9uXHJcbiAgICB0aGlzLmN1cnJNb3VzZVBvc2l0aW9uID0gZVt0aGlzLmNvbnRyb2wub2Zmc2V0UHJvcGVydHldO1xyXG4gICAgdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSB0aGlzLmdldFNjcm9sbERpcmVjdGlvbih0aGlzLmN1cnJNb3VzZVBvc2l0aW9uKTtcclxuICAgIHRoaXMuc2Nyb2xsTWF4ID0gdGhpcy5jb250cm9sLnZpZXdwb3J0U2Nyb2xsTWF4O1xyXG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG8odGhpcy5uZXh0U3RlcCgpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbmV4dFN0ZXAoKTogbnVtYmVyIHtcclxuICAgIC8vIENoZWNrIHdoaWNoIGRpcmVjdGlvbiBzaG91bGQgdGhlIHNjcm9sbCBnbyAoZm9yd2FyZCBvciBiYWNrd2FyZClcclxuICAgIGlmICh0aGlzLnNjcm9sbERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XHJcbiAgICAgIC8vIFNjcm9sbCBmb3J3YXJkXHJcbiAgICAgIGNvbnN0IHNjcm9sbEZvcndhcmRJbmNyZW1lbnQ6IG51bWJlciA9IHRoaXMuZ2V0U2Nyb2xsRm9yd2FyZFN0ZXAoKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBpbmNyZW1lbnRhbCBwb3NpdGlvbiBpcyBiaWdnZXIgdGhhbiB0aGUgc2Nyb2xsIG1heFxyXG4gICAgICBpZiAoc2Nyb2xsRm9yd2FyZEluY3JlbWVudCA+PSB0aGlzLnNjcm9sbE1heCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbE1heDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2Nyb2xsRm9yd2FyZEluY3JlbWVudDtcclxuICAgIH1cclxuICAgIC8vIFNjcm9sbCBiYWNrd2FyZFxyXG4gICAgY29uc3Qgc2Nyb2xsQmFja3dhcmRJbmNyZW1lbnQ6IG51bWJlciA9IHRoaXMuZ2V0U2Nyb2xsQmFja3dhcmRTdGVwKCk7XHJcblxyXG4gICAgaWYgKHNjcm9sbEJhY2t3YXJkSW5jcmVtZW50IDw9IDApIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2Nyb2xsQmFja3dhcmRJbmNyZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsYmFjayB3aGVuIG1vdXNlIGlzIHN0aWxsIGRvd24gb24gdGhlIHRyYWNrXHJcbiAgICogSW5jcmVtZW50YWxseSBzY3JvbGxzIHRvd2FyZHMgdGFyZ2V0IHBvc2l0aW9uIHVudGlsIHJlYWNoZWRcclxuICAgKi9cclxuICBvblRyYWNrT25nb2luZ01vdXNlZG93bigpOiBPYnNlcnZhYmxlPHVua25vd24+IHtcclxuICAgIGNvbnN0IHBvc2l0aW9uOiBudW1iZXIgPSB0aGlzLm5leHRTdGVwKCk7XHJcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxUbyhwb3NpdGlvbikucGlwZShcclxuICAgICAgdGFrZVdoaWxlKCgpID0+ICF0aGlzLmlzUmVhY2hlZChwb3NpdGlvbikpLFxyXG4gICAgICBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5vblRyYWNrT25nb2luZ01vdXNlZG93bigpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBmbGFnIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzY3JvbGwgZnJvbSB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgdGhlIGZpbmFsIHN0ZXAgb3Igbm90XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc1JlYWNoZWQocG9zaXRpb246IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgaWYgKHRoaXMuc2Nyb2xsRGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcclxuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IHRoaXMuc2Nyb2xsTWF4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uIDw9IDA7XHJcbiAgfVxyXG59XHJcbiJdfQ==