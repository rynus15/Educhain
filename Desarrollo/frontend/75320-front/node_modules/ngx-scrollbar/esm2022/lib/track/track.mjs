import { Directive, effect } from '@angular/core';
import { from } from 'rxjs';
import { TrackAdapter } from './track-adapter';
import * as i0 from "@angular/core";
export class TrackXDirective extends TrackAdapter {
    get contentSize() {
        return this.cmp.viewport.contentWidth;
    }
    constructor() {
        effect(() => {
            if (this.cmp.direction() === 'rtl') {
                this.getCurrPosition = () => {
                    const offset = this.contentSize - this.viewportSize - this.control.viewportScrollOffset;
                    return offset * this.size / this.contentSize;
                };
                this.getScrollDirection = (position) => {
                    return position < this.getCurrPosition() ? 'forward' : 'backward';
                };
            }
            else {
                this.getCurrPosition = () => {
                    return this.control.viewportScrollOffset * this.size / this.contentSize;
                };
                this.getScrollDirection = (position) => {
                    return position > this.getCurrPosition() ? 'forward' : 'backward';
                };
            }
        });
        super();
    }
    scrollTo(start) {
        return from(this.cmp.scrollTo({ start, duration: this.cmp.trackScrollDuration() }));
    }
    getScrollForwardStep() {
        return this.control.viewportScrollOffset + this.viewportSize;
    }
    getScrollBackwardStep() {
        return this.control.viewportScrollOffset - this.viewportSize;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: TrackXDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.11", type: TrackXDirective, isStandalone: true, selector: "[scrollbarTrackX]", providers: [{ provide: TrackAdapter, useExisting: TrackXDirective }], usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: TrackXDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[scrollbarTrackX]',
                    providers: [{ provide: TrackAdapter, useExisting: TrackXDirective }]
                }]
        }], ctorParameters: () => [] });
export class TrackYDirective extends TrackAdapter {
    get contentSize() {
        return this.cmp.viewport.contentHeight;
    }
    getCurrPosition() {
        return this.control.viewportScrollOffset * this.size / this.contentSize;
    }
    getScrollDirection(position) {
        return position > this.getCurrPosition() ? 'forward' : 'backward';
    }
    scrollTo(top) {
        return from(this.cmp.scrollTo({ top, duration: this.cmp.trackScrollDuration() }));
    }
    getScrollForwardStep() {
        return this.control.viewportScrollOffset + this.viewportSize;
    }
    getScrollBackwardStep() {
        return this.control.viewportScrollOffset - this.viewportSize;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: TrackYDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.11", type: TrackYDirective, isStandalone: true, selector: "[scrollbarTrackY]", providers: [{ provide: TrackAdapter, useExisting: TrackYDirective }], usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.11", ngImport: i0, type: TrackYDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[scrollbarTrackY]',
                    providers: [{ provide: TrackAdapter, useExisting: TrackYDirective }]
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc2Nyb2xsYmFyL3NyYy9saWIvdHJhY2svdHJhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEQsT0FBTyxFQUFFLElBQUksRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUN4QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7O0FBTy9DLE1BQU0sT0FBTyxlQUFnQixTQUFRLFlBQVk7SUFFL0MsSUFBYyxXQUFXO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDO0lBQ3hDLENBQUM7SUFNRDtRQUNFLE1BQU0sQ0FBQyxHQUFHLEVBQUU7WUFDVixJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLEtBQUssS0FBSyxFQUFFLENBQUM7Z0JBQ25DLElBQUksQ0FBQyxlQUFlLEdBQUcsR0FBVyxFQUFFO29CQUNsQyxNQUFNLE1BQU0sR0FBVyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztvQkFDaEcsT0FBTyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO2dCQUMvQyxDQUFDLENBQUM7Z0JBQ0YsSUFBSSxDQUFDLGtCQUFrQixHQUFHLENBQUMsUUFBZ0IsRUFBMEIsRUFBRTtvQkFDckUsT0FBTyxRQUFRLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztnQkFDcEUsQ0FBQyxDQUFDO1lBQ0osQ0FBQztpQkFBTSxDQUFDO2dCQUNOLElBQUksQ0FBQyxlQUFlLEdBQUcsR0FBVyxFQUFF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dCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIGVmZmVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBmcm9tLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IFRyYWNrQWRhcHRlciB9IGZyb20gJy4vdHJhY2stYWRhcHRlcic7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzdGFuZGFsb25lOiB0cnVlLFxyXG4gIHNlbGVjdG9yOiAnW3Njcm9sbGJhclRyYWNrWF0nLFxyXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogVHJhY2tBZGFwdGVyLCB1c2VFeGlzdGluZzogVHJhY2tYRGlyZWN0aXZlIH1dXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUcmFja1hEaXJlY3RpdmUgZXh0ZW5kcyBUcmFja0FkYXB0ZXIge1xyXG5cclxuICBwcm90ZWN0ZWQgZ2V0IGNvbnRlbnRTaXplKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAudmlld3BvcnQuY29udGVudFdpZHRoO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q3VyclBvc2l0aW9uOiAoKSA9PiBudW1iZXI7XHJcblxyXG4gIGdldFNjcm9sbERpcmVjdGlvbjogKHBvc2l0aW9uOiBudW1iZXIpID0+ICdmb3J3YXJkJyB8ICdiYWNrd2FyZCc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgZWZmZWN0KCgpID0+IHtcclxuICAgICAgaWYgKHRoaXMuY21wLmRpcmVjdGlvbigpID09PSAncnRsJykge1xyXG4gICAgICAgIHRoaXMuZ2V0Q3VyclBvc2l0aW9uID0gKCk6IG51bWJlciA9PiB7XHJcbiAgICAgICAgICBjb25zdCBvZmZzZXQ6IG51bWJlciA9IHRoaXMuY29udGVudFNpemUgLSB0aGlzLnZpZXdwb3J0U2l6ZSAtIHRoaXMuY29udHJvbC52aWV3cG9ydFNjcm9sbE9mZnNldDtcclxuICAgICAgICAgIHJldHVybiBvZmZzZXQgKiB0aGlzLnNpemUgLyB0aGlzLmNvbnRlbnRTaXplO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5nZXRTY3JvbGxEaXJlY3Rpb24gPSAocG9zaXRpb246IG51bWJlcik6ICdmb3J3YXJkJyB8ICdiYWNrd2FyZCcgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uIDwgdGhpcy5nZXRDdXJyUG9zaXRpb24oKSA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCc7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmdldEN1cnJQb3NpdGlvbiA9ICgpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbC52aWV3cG9ydFNjcm9sbE9mZnNldCAqIHRoaXMuc2l6ZSAvIHRoaXMuY29udGVudFNpemU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdldFNjcm9sbERpcmVjdGlvbiA9IChwb3NpdGlvbjogbnVtYmVyKTogJ2ZvcndhcmQnIHwgJ2JhY2t3YXJkJyA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gcG9zaXRpb24gPiB0aGlzLmdldEN1cnJQb3NpdGlvbigpID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJztcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHN1cGVyKCk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgc2Nyb2xsVG8oc3RhcnQ6IG51bWJlcik6IE9ic2VydmFibGU8dm9pZD4ge1xyXG4gICAgcmV0dXJuIGZyb20odGhpcy5jbXAuc2Nyb2xsVG8oeyBzdGFydCwgZHVyYXRpb246IHRoaXMuY21wLnRyYWNrU2Nyb2xsRHVyYXRpb24oKSB9KSk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0U2Nyb2xsRm9yd2FyZFN0ZXAoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRyb2wudmlld3BvcnRTY3JvbGxPZmZzZXQgKyB0aGlzLnZpZXdwb3J0U2l6ZTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZXRTY3JvbGxCYWNrd2FyZFN0ZXAoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRyb2wudmlld3BvcnRTY3JvbGxPZmZzZXQgLSB0aGlzLnZpZXdwb3J0U2l6ZTtcclxuICB9XHJcbn1cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHN0YW5kYWxvbmU6IHRydWUsXHJcbiAgc2VsZWN0b3I6ICdbc2Nyb2xsYmFyVHJhY2tZXScsXHJcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBUcmFja0FkYXB0ZXIsIHVzZUV4aXN0aW5nOiBUcmFja1lEaXJlY3RpdmUgfV1cclxufSlcclxuZXhwb3J0IGNsYXNzIFRyYWNrWURpcmVjdGl2ZSBleHRlbmRzIFRyYWNrQWRhcHRlciB7XHJcblxyXG4gIHByb3RlY3RlZCBnZXQgY29udGVudFNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNtcC52aWV3cG9ydC5jb250ZW50SGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGdldEN1cnJQb3NpdGlvbigpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udHJvbC52aWV3cG9ydFNjcm9sbE9mZnNldCAqIHRoaXMuc2l6ZSAvIHRoaXMuY29udGVudFNpemU7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0U2Nyb2xsRGlyZWN0aW9uKHBvc2l0aW9uOiBudW1iZXIpOiAnZm9yd2FyZCcgfCAnYmFja3dhcmQnIHtcclxuICAgIHJldHVybiBwb3NpdGlvbiA+IHRoaXMuZ2V0Q3VyclBvc2l0aW9uKCkgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHNjcm9sbFRvKHRvcDogbnVtYmVyKTogT2JzZXJ2YWJsZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gZnJvbSh0aGlzLmNtcC5zY3JvbGxUbyh7IHRvcCwgZHVyYXRpb246IHRoaXMuY21wLnRyYWNrU2Nyb2xsRHVyYXRpb24oKSB9KSk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0U2Nyb2xsRm9yd2FyZFN0ZXAoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRyb2wudmlld3BvcnRTY3JvbGxPZmZzZXQgKyB0aGlzLnZpZXdwb3J0U2l6ZTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZXRTY3JvbGxCYWNrd2FyZFN0ZXAoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRyb2wudmlld3BvcnRTY3JvbGxPZmZzZXQgLSB0aGlzLnZpZXdwb3J0U2l6ZTtcclxuICB9XHJcbn1cclxuIl19